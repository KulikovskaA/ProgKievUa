// Функции
// function greet(){ // создаем функцию с именем 'greet'
//   console.log( 'Hello human' ); // тело функции
// }
// greet(); // вызов функции

// Но что если в следющий раз мы захотим поприветствовать человека в Alert ?
// Будет неразумно создавать новую функцию. По сути console.log уже выполняет свою функцию. Как и алерт. Таким образом разумнее сделать так:


// function greet(){
//   return 'Hello human'; // функция возвращает строку 'Heelo human'; Тобишь оставляет за собой после вызова
// }
// console.log( greet() ); // в console.log передаем РЕЗУЛЬТАТ ВЫПОЛЕНИЯ ФУНКЦИИ (то что она возвращает)
// alert( greet() ); // также и с alert

// Но сейчас не осоого смысла в функции, так как мы можем писать строку прямо в функции вывода
// но, если добавть сюда аргументы:


// function greet( name ){ // name - аргумент функции в который при вызове будет что-то записываться
//   return 'Hello '+name; // аргумент функции может использоваться только врамках этой функции
// }
//
// console.log( greet( 'Bob' ) ); // а здесь при вызове функции greet мы отправляем в нее имя, которое будет приниматься в аргумент name и использоваться внутри функции

// Анонимные функции
// Приведенные ниже 2 способа практически ничем не отличаются функционально
// var func = function(){
//   console.log( 'X' );
// }
// func()
//
// function func2(){
//   console.log( 'Y' );
// }
// func2()

// !!!!!! НО
// Если мы сделаем следующее:
// func()
// var func = function(){
//   console.log( 'X' );
// }
// получаем ошибку
// а в случае с именованными функциями этой ошибки не будт:
// func2()
// function func2() {
//   console.log( 'Y' );
// }
//Интерпритатор по разному реагирует на создание ФУНКЦИИ и переменой в которой лежит функция


// Области видимости

// function func(){
//   var a = 20; // локальная переменная
// }
// func()
// console.log( a ); // локлаьная переменная была срздана внутри функции. После выполнения функции все что было в ней просто вытирается

// var a = 10; // глобальная переменная
// function func(){
//   console.log( a ); // глобальные переменные "проваливаются" внутрь функций и доступны там
// }
// func();

// var a = 10;
// function func(){
//   var a = 20;
//   console.log( a ); // будет выведена та переменная, которая лежит в более близкой области видимости. Тобишь в локальной
// }
// func()

// function func(){
//   console.log( a ); // выводим еще не созданную переменную, но ошибки не будет, а будет undefined
//   var a = 10;
// }
// func()

// // Так происходит, потому что интерпритатор "поднимает" объявление перменной в рамках этой области видимости
// // Грубо говоря, интерпритатор делает следующее:
// function func(){
//   var a;
//   console.log( a );
//   a = 10;
// }
// func()

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!! Замыкания !!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// 
// function func(){
//   var a = 10;
//   return function(){ // возвращаю функцию.
//     return a;
//   }
// }
//
// console.log( func()() ); // таким образом, при вызове func мы получим ТЕЛО функции которую она возвращает.
// // А вторыми круглыми скобками мы запускаем возвращенную функцию ( заводим ее тело )
//
// function func(){
//   var a = 10;
//   return function(){
//     return a;
//   }
// }
//
// function func2(){
//   var a = 50;
//   console.log( func()() ); // при вызове func2 в консоль выведется переменная "a"
//   // потомуч то эта переменная возвращается в функции func() ( ИМЕННО func(). Тобишь в той, которую возвращает функция func )
//   // но какая именно выведется "a" ? Ведь в функции func2 ближайшей переменной "a" является та, которая создана на 112 строке
//   // выведется та, которая создана на 105 строке потому что  возвращаемая функция (106) имеет доступ к ОБЪЕКТУ в котором хранятся локальные переменные функции func (104)
//   // При вызове func создается объект с е локальными переменными и возвращаемая функция может им пользоваться
//   // Это единственный способ получить локальную переменную, так как они "не вываливаются" за рамки функции, но доступны во внутренних фунциях по цепочке
// }
// func2()
//
// // Для удобства перепишем так:
// function func(){
//   var a = 10;
//   return function(){
//     return a;
//   }
// }
//
// var closure = func();
//
// function func2(){
//   var a = 50;
//   console.log( closure() ); // получили локлаьную переменную из func. Так как closure имеет доступ к локальным переменным функции в которой она находится
// }
// func2()
//
// Анонимная самовызывающаяся функция:
// (function(){
//   console.log( 'KUKU' );
// }());
//
// Пример замыканий и немноо другой вид их записи
//
// var counter = (function(){
//   var i = 0;
//   return function(){
//     return i++;
//   }
// }())
// console.log( counter() );
// console.log( counter() );
// console.log( counter() );
// console.log( counter() );

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!


// Методы и клюевое слово this
// var man = {
//   name: 'Alexandr',
//   intro: function(){
//     return "I`m " + man.name;
//   }
// }
//
// console.log( man.intro() );

// var man = {
//   name: 'Alexandr',
//   intro: function(){
//     return "I`m " + this.name; //при вызове этого метода this будет указывать на объект в котором находится функция и из которого она вызывается
//   }
// }
//
// console.log( man.intro() );

// function intro(){
//   return "I`m " + this.name;
// }
//
// var man = {
//   name: 'Alexandr',
//   intro: intro
// }
// var man2 = {
//   name: 'Andrey',
//   intro: intro
// }
//
// console.log( man.intro() );
// console.log( man2.intro() );

//Call and apply

// function intro(){
//   return "I`m " + this.name;
// }
// var man = {
//   name: 'Alexandr',
//   intro: intro
// }
// var man2 = {
//   name: 'Andrey',
//   intro: intro
// }
//
// console.log( man.intro() );
// console.log( man2.intro.call( man ) ); // указали на какой объект ссылаться this`у

// !!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!
//      HOMEWORK
// !!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!

// var btns = document.getElementsByTagName('button');
//
// for (var i = 0; i < 5; i++) {
//   btns[i].onclick = function(){
//     console.log( i );
//   }
// }
